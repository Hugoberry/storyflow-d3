<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head lang="en">
	<meta charset="UTF-8">
	<title>StoryFlow: Tracking the Evolution of Stories</title>
	<link rel="stylesheet" type="text/css" href="lib/jquery-ui-themes-1.11.4/themes/flick/jquery-ui.min.css"/>
	<script type="text/javascript" src="lib/d3.v3.js"></script>
	<script type="text/javascript" src="lib/jquery-ui-1.11.4/external/jquery/jquery.js"></script>
	<script type="text/javascript" src="lib/jquery-ui-1.11.4/jquery-ui.min.js"></script>
	<script type="text/javascript" src="lib/randomColor.js"></script>
</head>
<body>
<script type="text/javascript">
	// http://stackoverflow.com/questions/9838812/how-can-i-open-a-json-file-in-javascript-without-jquery
	function loadJSON(path, success, error) {
		var xhr = new XMLHttpRequest();

		xhr.onreadystatechange = function () {
			if (xhr.readyState === XMLHttpRequest.DONE) {
				if (xhr.status === 200) {
					if (success)
						success(JSON.parse(xhr.responseText));
				} else {
					if (error)
						error(xhr);
				}
			}
		};

		xhr.open("GET", path, true);
		xhr.send();
	}

	var annotateDataset = function (dataset, options) {
		/************************************************* ALGORITHM **************************************************/
		/********* Implementation of the algorithm presented in "StoryFlow: Tracking the Evolution of Stories" ********/

		// Compute the story timeframe
		var timeframe = dataset.sessions.map(function(x) { return { start: x.start, end: x.end } })
				.reduce(function(x, y) { return { start: Math.min(x.start, y.start), end: Math.max(x.end, y.end) } });

		console.log("Timeframe: ", timeframe);

		dataset.d3 = { time: [] };

		var enforceHierarchy = function(moment, charactersMapping, performSorting) {
			// Place the locations with the highest number of characters first
			moment.locations.sort(function(x, y) {
				return x.sessions.map(function(x) { return dataset.sessions[x].members.length; })
								.reduce(function(x, y) { return x + y; }) <
						y.sessions.map(function(y) { return dataset.sessions[y].members.length; })
								.reduce(function(x, y) { return x + y; });
			});

			// Sort the sessions
			if(performSorting != undefined && performSorting == true)
				moment.locations.forEach(function(location) {
					location.sessions.sort(function(x, y) {
						var xWeight = dataset.sessions[x].members
										.map(function(x) { return charactersMapping[moment.sortedCharacters.indexOf(x)]; })
										.reduce(function(x, y) { return x + y; })
								/ dataset.sessions[x].members.length;

						var yWeight = dataset.sessions[y].members
										.map(function(y) { return charactersMapping[moment.sortedCharacters.indexOf(y)]; })
										.reduce(function(x, y) { return x + y; })
								/ dataset.sessions[y].members.length;

						return xWeight > yWeight;
					});
				});

			var characters = moment.locations.map(function(x) {
				return x.sessions.map(function(x) {
					var members = dataset.sessions[x].members;

					if(performSorting != undefined && performSorting == true)
						members.sort(function (x, y) { return charactersMapping[moment.sortedCharacters.indexOf(x)] > charactersMapping[moment.sortedCharacters.indexOf(y)]; });

					return members;
				})
			});

			moment.sortedCharacters = [];

			characters.forEach(function(l) {
				l.forEach(function(s) {
					s.forEach(function(c) {
						moment.sortedCharacters.push(c);
					})
				})
			});
		};

		console.log("Building the relationship trees...");

		// Construct the relationship trees (one for each time unit)
		for(var time = timeframe.start; time < timeframe.end; ++time) {
			var moment = dataset.d3.time[time] = { locations: [ ], sortedCharacters: [ ] };

			// Append the sessions and the characters that belong to this moment
			for(var i = 0; i < dataset.sessions.length; ++i) {
				var session = dataset.sessions[i];
				var location = moment.locations[session.location];

				if(session.start <= time && time < session.end) {
					if(location == undefined)
						location = moment.locations[session.location] = { sessions: [ ] };

					location.sessions.push(i);
				}
			}

			enforceHierarchy(moment, dataset.characters.map(function(_, i, _) { return i; }), false);

			// TODO: Place the other locations such that the number of crossings is minimized
		}

		console.log("Finished building the relationship trees.");

		var sortMoment = function(referenceMoment, currentMoment, sortRestrictions) {
			// Compute the number of crossings in the given realization matrix
			var computeCrossings = function(matrix) {
				var crossings = 0;

				for(var topRow = 0; topRow < referenceMoment.length - 1; ++topRow)
					for(var bottomRow = topRow + 1; bottomRow < referenceMoment.length; ++bottomRow)
						for(var leftColumn = 0; leftColumn < currentMoment.length - 1; ++leftColumn)
							for(var rightColumn = leftColumn + 1; rightColumn < currentMoment.length; ++rightColumn)
								crossings +=
										matrix[topRow][rightColumn] *
										matrix[bottomRow][leftColumn];

				return crossings;
			};

			var columnBarycenters = [];
			var currentMapping = currentMoment.map(function(_, i, _) { return i; });
			var backupMapping = currentMoment.map(function(_, i, _) { return i; });
			var matrix = [];

			// Compute the realization matrix
			for(var r = 0; r < referenceMoment.length; ++r) {
				matrix[r] = [];

				for(var c = 0; c < currentMoment.length; ++c)
					matrix[r][c] = referenceMoment[r] == currentMoment[c] ? 1 : 0;
			}

			// Compute the column barycenters
			for(c = 0; c < currentMoment.length; ++c) {
				var weightedSum = 0;

				for (r = 0; r < referenceMoment.length; ++r) {
					weightedSum += (r + 1) * matrix[r][c];
				}

				columnBarycenters[c] = weightedSum;
			}

			// Compute the number of crossings before sorting the columns
			var crossingsBefore = computeCrossings(matrix);

			// Sort the columns by their barycenters, while making sure that we respect the hierarchical structure
			for(var restriction = 0, offset = 0; restriction < sortRestrictions.length; ++restriction) {
				for(i = offset; i < offset + sortRestrictions[restriction]; ++i) {
					for(var k = i + 1; k < offset + sortRestrictions[restriction]; ++k)
						if(columnBarycenters[i] > columnBarycenters[k]) {
							var tmp = columnBarycenters[i];
							columnBarycenters[i] = columnBarycenters[k];
							columnBarycenters[k] = tmp;

							tmp = currentMapping[currentMapping[i]];
							currentMapping[currentMapping[i]] = currentMapping[currentMapping[k]];
							currentMapping[currentMapping[k]] = tmp;

							for(var r = 0; r < referenceMoment.length; ++r) {
								var tmp = matrix[r][currentMapping[i]];
								matrix[r][currentMapping.indexOf(i)] = matrix[r][currentMapping[k]];
								matrix[r][currentMapping.indexOf(k)] = tmp;
							}

//							console.log(matrix);
						}
				}

				offset += sortRestrictions[restriction];
			}

			// Compute the number of crossings after column sorting
			var crossingsAfter = computeCrossings(matrix);

			if(crossingsBefore <= crossingsAfter) {
				return { mapping: backupMapping, crossings: crossingsBefore };
			}

			return { mapping: currentMapping, crossings: crossingsAfter };
		};

		console.log("Starting sweeping...");

		var bestCrossings = -1;
		var bestDataset = jQuery.extend(true, {}, dataset);

		for(var iter = 0; iter < options.algorithm.sweepingMaxIterations; ++iter) {
			console.log(" Sweep #", iter);
			var totalCrossings = 0;

			// Sweep left->right
			for (t = timeframe.start + 1; t < timeframe.end; ++t) {
				var referenceMoment = dataset.d3.time[t - 1];
				var currentMoment = dataset.d3.time[t];

				var sortRestrictions = currentMoment.locations.
						map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
						reduce(function(x, y) { return x.concat(y); });

				var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);
				totalCrossings += result.crossings;

				enforceHierarchy(currentMoment, result.mapping, true);
			}

			if(bestCrossings == -1 || bestCrossings > totalCrossings) {
				console.log("Best number of crossings: ", bestCrossings);
				bestCrossings = totalCrossings;
				bestDataset = jQuery.extend(true, {}, dataset);
			}

			totalCrossings = 0;

			// Set the order for all time frames as the order at the last time frame
			referenceMoment = dataset.d3.time[timeframe.end -2];
			currentMoment = dataset.d3.time[timeframe.end -1];

			// Sweep right->left to fix the order
			var sortRestrictions = currentMoment.locations.
					map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
					reduce(function(x, y) { return x.concat(y); });


			var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);

			for (t = timeframe.start + 1; t < timeframe.end; ++t) {
				dataset.d3.time[t].sortedCharacters.sort(function(x, y) {
					var xIndex = currentMoment.sortedCharacters.indexOf(x);
					var yIndex = currentMoment.sortedCharacters.indexOf(x);

					if(xIndex == -1) return false;
					if(yIndex == -1) return false;

					return result.mapping[xIndex] > result.mapping[yIndex];
				});

				var oneToOneMapping = dataset.d3.time[t].sortedCharacters.map(function(_, i, _) { return i; });

				enforceHierarchy(dataset.d3.time[t], oneToOneMapping, false);
			}

			// Sweep right->left
			for (t = timeframe.end - 2; t >= 0; --t) {
				referenceMoment = dataset.d3.time[t  + 1];
				currentMoment = dataset.d3.time[t];

				var sortRestrictions = currentMoment.locations.
						map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
						reduce(function(x, y) { return x.concat(y); });

				var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);
				totalCrossings += result.crossings;

				enforceHierarchy(currentMoment, result.mapping, true);
			}

			// Set the order for all time frames as the order at the first time frame
			referenceMoment = dataset.d3.time[timeframe.start];
			currentMoment = dataset.d3.time[timeframe.start + 1];

			// Sweep right->left to fix the order
			var sortRestrictions = currentMoment.locations.
					map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
					reduce(function(x, y) { return x.concat(y); });


			var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);

			for (t = timeframe.start + 1; t < timeframe.end; ++t) {
				dataset.d3.time[t].sortedCharacters.sort(function(x, y) {
					var xIndex = currentMoment.sortedCharacters.indexOf(x);
					var yIndex = currentMoment.sortedCharacters.indexOf(x);

					if(xIndex == -1) return false;
					if(yIndex == -1) return false;

					return result.mapping[xIndex] > result.mapping[yIndex];
				});

				var oneToOneMapping = dataset.d3.time[t].sortedCharacters.map(function(_, i, _) { return i; });

				enforceHierarchy(dataset.d3.time[t], oneToOneMapping, false);
			}

			if(bestCrossings == -1 || bestCrossings > totalCrossings) {
				console.log("Best number of crossings: ", bestCrossings);
				bestCrossings = totalCrossings;
				bestDataset = jQuery.extend(true, {}, dataset);
			}
		}

		dataset = JSON.parse(JSON.stringify(bestDataset));

//		referenceMoment = dataset.d3.time[timeframe.end -2];
//		currentMoment = dataset.d3.time[timeframe.end -1];

//		var sortRestrictions = currentMoment.locations.
//				map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
//				reduce(function(x, y) { return x.concat(y); });
//
//
//		var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);
//
//		for (t = timeframe.start + 1; t < timeframe.end; ++t) {
//			dataset.d3.time[t].sortedCharacters.sort(function(x, y) {
//				var xIndex = currentMoment.sortedCharacters.indexOf(x);
//				var yIndex = currentMoment.sortedCharacters.indexOf(x);
//
//				if(xIndex == -1) return false;
//				if(yIndex == -1) return false;
//
//				return result.mapping[xIndex] > result.mapping[yIndex];
//			});
//
//			var oneToOneMapping = dataset.d3.time[t].sortedCharacters.map(function(_, i, _) { return i; });
//
//			enforceHierarchy(dataset.d3.time[t], oneToOneMapping, false);
//		}

		/***************************************************** D3 *****************************************************/

		// Remove the previous SVG container
		d3.select(options.svg.element).select("svg").remove();

		// Create the SVG container
		var svg = d3.select(options.svg.element).append("svg").attr("height", options.svg.height).attr("width", options.svg.width);

		// Generate the colors of the characters
		var colors = dataset.characters.length <= 10 ? d3.scale.category10() : d3.scale.category20(); // randomColor({count: dataset.characters.length});

		// Assign each character a color
		for(i = 0; i < dataset.characters.length; ++i) {
			dataset.characters[i].d3 = { color: colors(i) };
		}

		// Compute the maximum number of characters in a time unit
		var maxCharacters = dataset.d3.time.map(function(time) { return time.sortedCharacters.length; })
				.reduce(function(x, y) { return Math.max(x, y); });


		console.log("Maximum characters in a time unit: ", maxCharacters);

		// Create various scales used to process the dataset
		var verticalScale = d3.scale.linear()
				.domain([0, maxCharacters])
				.range([0, options.svg.height]);

		var horizontalScale = d3.scale.linear()
				.domain([timeframe.start, timeframe.end])
				.range([0, options.svg.width]);

		// Compute path of each character
		for(var t = 0; t < dataset.d3.time.length; ++t) {
			var time = dataset.d3.time[t];

			var sortRestrictions = time.locations.
					map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
					reduce(function(x, y) { return x.concat(y); });

			var offset = 0;

			sortRestrictions.forEach(function(restriction) {
				var mean = 0;

				for(i = 0; i < restriction; ++i) {
					mean += verticalScale(offset + i);
				}

				mean /= restriction;

				for(i = 0; i < restriction; ++i) {
					var character = dataset.characters[time.sortedCharacters[offset + i]];

					if(character.d3.points == undefined)
						character.d3.points = [];

					character.d3.points.push({ x: horizontalScale(t), y: mean + ((verticalScale(offset + i) - mean) / 3) });
				}

				offset += restriction;
			});

//			for(var i = 0; i < time.sortedCharacters.length; ++i) {
//				var character = dataset.characters[time.sortedCharacters[i]];
//
//				if(character.d3.points == undefined)
//					character.d3.points = [];
//
//				character.d3.points.push({ x: horizontalScale(t), y: verticalScale(i) });
//			}
		}

		// Draw the story lines
		dataset.characters.forEach(function (character) {
			var line_function = d3.svg.line().interpolate(options.characters.interpolation)
					.x(function (d) { return d.x; })
					.y(function (d) { return d.y; });

			svg.append("path").attr("d", line_function(character.d3.points))
					.attr("id", "character_" + character.id)
					.attr("xlink:href", "character_" + character.id)
					.attr("fill", "none")
					.attr("stroke", character.d3.color)
					.attr("stroke-width", 2);
		});

		// Append the character names
		svg.selectAll("text").data(dataset.characters.map(function(x) { return x.name }))
				.enter()
				.append("text")
				.attr("x", 0)
				.attr("dy", 0)
				.append("textPath")
				.attr("xlink:href", function(d, i) { return "#character_" + i; })
				.text(function(d, i) { return d; });
	};

	var visualizeDataset = function(path, options) {
		loadJSON(path, function(dataset) {
			annotateDataset(dataset, options);
		}, null);
	};

	var options = {
		svg: {
			element: "#canvas",
			height: 1000,
			width: 16000
		},
		characters: {
			interpolation: "basis"
		},
		algorithm: {
			sweepingMaxIterations: 20
		}
	};

	$(document).ready(function() {
		$("#dataset").selectmenu({
			width: 230,
			select: function (event, ui) {
				visualizeDataset($("#dataset").val(), options);
			}
		});

		$("#interpolation").selectmenu({
			width: 200,
			select: function (event, ui) {
				options.characters.interpolation = ui.item.value;

				visualizeDataset($("#dataset").val(), options);
			}
		});

		visualizeDataset($("#dataset").val(), options);
	});
</script>

<table>
	<tr>
		<td>
			<select name="dataset" id="dataset">
				<option value="dataset/the_matrix.json">The Matrix</option>
				<option value="dataset/alice_in_wonderland.json">Alice in Wonderland</option>
				<option value="dataset/star_wars.json" selected>Star Wars</option>
				<option value="dataset/test.json">Test</option>
			</select>
		</td>
		<td>
			<select name="interpolation" id="interpolation">
				<option value="linear">Linear</option>
				<option value="step">Step</option>
				<option value="step-before">Step-before</option>
				<option value="step-after">Step-after</option>
				<option value="basis" selected>Basis</option>
				<option value="bundle">Bundle</option>
				<option value="cardinal">Cardinal</option>
				<option value="monotone">Monotone</option>
			</select>
		</td>
	</tr>
</table>

<div id="canvas"/>
</body>
</html>