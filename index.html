<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head lang="en">
	<meta charset="UTF-8">
	<title>StoryFlow: Tracking the Evolution of Stories</title>
	<link rel="stylesheet" type="text/css" href="lib/jquery-ui-themes-1.11.4/themes/flick/jquery-ui.min.css"/>
	<script type="text/javascript" src="lib/d3.v3.js"></script>
	<script type="text/javascript" src="lib/jquery-ui-1.11.4/external/jquery/jquery.js"></script>
	<script type="text/javascript" src="lib/jquery-ui-1.11.4/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript">
	var dataset = null;
	var svg = null;

	var options = {
		svg: {
			element: "#canvas",
			height: 1000,
			width: 16000
		},
		characters: {
			interpolation: "monotone",
			lineClass: "line",
			nameClass: "name",
			datasetTransitionDuration: 1000,
			sessionCoefficient: 3,
			strokeWidth: 4,
			highlightStrokeWidth: 8,
			highlightDuration: 400,
			nonHighlightedOpacity: 0.2
		},
		algorithm: {
			sweepingMaxIterations: 3
		}
	};

	$(document).ready(function() {
		svg = d3.select(options.svg.element).append("svg").attr("height", options.svg.height).attr("width", options.svg.width);

		function buildDrawStoryFlow(path, options) {
			d3.json(path, function(error, json) {
				if(error)
					return console.error(error);

				dataset = annotateDataset(json, options);
				drawStoryFlow(dataset, options);
			});
		};

		var datasetSelector = $("#dataset");

		datasetSelector.selectmenu({
			width: 230,
			select: function (event, ui) {
				buildDrawStoryFlow(ui.item.value, options);
			}
		});

		$("#interpolation").selectmenu({
			width: 200,
			select: function (event, ui) {
				options.characters.interpolation = ui.item.value;

				drawStoryFlow(dataset, options);
			}
		});

		buildDrawStoryFlow(datasetSelector.val(), options);
	});

	var drawStoryFlow = function(dataset, options) {
		// Generate the colors of the characters
		var colors = dataset.characters.length <= 10 ? d3.scale.category10() : d3.scale.category20();

		// Assign each character a color
		for(i = 0; i < dataset.characters.length; ++i) {
			dataset.characters[i].d3 = { color: colors(i) };
		}

		// Compute the maximum number of characters in a time unit
		var maxCharacters = dataset.d3.time.map(function(time) { return time.sortedCharacters.length; })
				.reduce(function(x, y) { return Math.max(x, y); });

		// Create various scales used to process the dataset
		var verticalScale = d3.scale.linear()
				.domain([0, maxCharacters])
				.range([0, options.svg.height]);

		// Compute the story timeframe
		var timeframe = dataset.sessions.map(function(x) { return { start: x.start, end: x.end } })
				.reduce(function(x, y) { return { start: Math.min(x.start, y.start), end: Math.max(x.end, y.end) } });

		var horizontalScale = d3.scale.linear()
				.domain([timeframe.start, timeframe.end])
				.range([0, options.svg.width]);

		// Compute path of each character
		for(var t = 0; t < dataset.d3.time.length; ++t) {
			var time = dataset.d3.time[t];

			var sortRestrictions = time.locations.
					map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
					reduce(function(x, y) { return x.concat(y); });

			var offset = 0;

			sortRestrictions.forEach(function(restriction) {
				var mean = 0;

				for(i = 0; i < restriction; ++i) {
					mean += verticalScale(offset + i);
				}

				mean /= restriction;

				for(i = 0; i < restriction; ++i) {
					var character = dataset.characters[time.sortedCharacters[offset + i]];

					if(character.d3.points == undefined)
						character.d3.points = [];

					character.d3.points.push({ x: horizontalScale(t), y: mean + ((verticalScale(offset + i) - mean) / options.characters.sessionCoefficient) });
				}

				offset += restriction;
			});
		}

		function toggleCharacterHighlight(character) {
			// Previously no characters were highlighted => fade all away
			if(dataset.d3.charactersHighlighted == 0)
				d3.selectAll("." + options.characters.lineClass)
						.transition()
						.duration(options.characters.highlightDuration)
						.style('opacity', options.characters.nonHighlightedOpacity)
						.style('stroke-width', options.characters.strokeWidth);

			character.d3.isHighlighted = !character.d3.isHighlighted;
			dataset.d3.charactersHighlighted += character.d3.isHighlighted ? 1 : -1;

			// No characters are highlighted => unfade them
			if(dataset.d3.charactersHighlighted == 0)
				d3.selectAll("." + options.characters.lineClass)
						.transition()
						.duration(options.characters.highlightDuration)
						.style('opacity', 1.0)
						.style('stroke-width', options.characters.strokeWidth);
		}

		dataset.d3.charactersHighlighted = 0;

		svg.on("click", function() {
			dataset.characters.forEach(function(character) {
				if(character.d3.isHighlighted)
					toggleCharacterHighlight(character);
			})
		});

		var line_function = d3.svg.line().interpolate(options.characters.interpolation)
				.x(function (d) { return d.x; })
				.y(function (d) { return d.y; });

		var lines = svg.selectAll("." + options.characters.lineClass).data(dataset.characters).attr("class", options.characters.lineClass);

		function setCharacterLinesAttributes(lines) {
			return lines
					.attr("class", options.characters.lineClass)
					.attr("id", function(d) { return d.id; })
					.attr("xlink:href", function(d) { return d.id; })
					.attr("d", function(d) { return line_function(d.d3.points); })
					.attr("fill", "none")
					.attr("stroke", function(d) { return d.d3.color; })
					.attr("stroke-width", options.characters.strokeWidth)
					.style('opacity', 1.0)
		}

		setCharacterLinesAttributes(lines.transition().duration(options.characters.datasetTransitionDuration));
		setCharacterLinesAttributes(lines.enter().append("path"))
				.on("click", function(d) {
					toggleCharacterHighlight(d);

					d3.select(this)
							.transition()
							.duration(options.characters.highlightDuration)
							.style('opacity', dataset.d3.charactersHighlighted == 0 || d.d3.isHighlighted ? 1.0 : options.characters.nonHighlightedOpacity)
							.style('stroke-width', d.d3.isHighlighted ? options.characters.highlightStrokeWidth : options.characters.strokeWidth);

					d3.event.stopPropagation();
				});

		lines.exit().remove();

		var names = svg.selectAll("." + options.characters.nameClass).data(dataset.characters).attr("class", options.characters.nameClass);

		function setCharacterNamesAttributes(names) {
			return names
					.attr("class", options.characters.nameClass)
					.attr("x", 0)
					.attr("dy", 0)
					.attr("xlink:href", function(d, i) { return "#" + i; })
					.text(function(d) { return d.name; });
		}

		setCharacterNamesAttributes(names.transition().duration(options.characters.datasetTransitionDuration));
		setCharacterNamesAttributes(names.enter().append("text").append("textPath"));

		names.exit().remove();
	};

	// (Partial) Implementation of the algorithm presented in "StoryFlow: Tracking the Evolution of Stories"
	function annotateDataset(dataset, options) {
		// Compute the story timeframe
		var timeframe = dataset.sessions.map(function(x) { return { start: x.start, end: x.end } })
				.reduce(function(x, y) { return { start: Math.min(x.start, y.start), end: Math.max(x.end, y.end) } });

		dataset.d3 = { time: [] };

		var enforceHierarchy = function(moment, charactersMapping, performSorting) {
			// Place the locations with the highest number of characters first
			moment.locations.sort(function(x, y) {
				return x.sessions.map(function(x) { return dataset.sessions[x].members.length; })
								.reduce(function(x, y) { return x + y; }) <
						y.sessions.map(function(y) { return dataset.sessions[y].members.length; })
								.reduce(function(x, y) { return x + y; });
			});

			// Sort the sessions
			if(performSorting != undefined && performSorting == true)
				moment.locations.forEach(function(location) {
					location.sessions.sort(function(x, y) {
						var xWeight = dataset.sessions[x].members
										.map(function(x) { return charactersMapping[moment.sortedCharacters.indexOf(x)]; })
										.reduce(function(x, y) { return x + y; })
								/ dataset.sessions[x].members.length;

						var yWeight = dataset.sessions[y].members
										.map(function(y) { return charactersMapping[moment.sortedCharacters.indexOf(y)]; })
										.reduce(function(x, y) { return x + y; })
								/ dataset.sessions[y].members.length;

						return xWeight > yWeight;
					});
				});

			var characters = moment.locations.map(function(x) {
				return x.sessions.map(function(x) {
					var members = dataset.sessions[x].members;

					if(performSorting != undefined && performSorting == true)
						members.sort(function (x, y) { return charactersMapping[moment.sortedCharacters.indexOf(x)] > charactersMapping[moment.sortedCharacters.indexOf(y)]; });

					return members;
				})
			});

			moment.sortedCharacters = [];

			characters.forEach(function(l) {
				l.forEach(function(s) {
					s.forEach(function(c) {
						moment.sortedCharacters.push(c);
					})
				})
			});
		};

		console.log("Building the relationship trees...");

		// Construct the relationship trees (one for each time unit)
		for(var time = timeframe.start; time < timeframe.end; ++time) {
			var moment = dataset.d3.time[time] = { locations: [ ], sortedCharacters: [ ] };

			// Append the sessions and the characters that belong to this moment
			for(var i = 0; i < dataset.sessions.length; ++i) {
				var session = dataset.sessions[i];
				var location = moment.locations[session.location];

				if(session.start <= time && time < session.end) {
					if(location == undefined)
						location = moment.locations[session.location] = { sessions: [ ] };

					location.sessions.push(i);
				}
			}

			enforceHierarchy(moment, dataset.characters.map(function(_, i, _) { return i; }), false);

			// TODO: Place the other locations such that the number of crossings is minimized
		}

		console.log("Finished building the relationship trees.");

		function computeRealizationMatrix(referenceMoment, currentMoment) {
			var matrix = [];

			// Compute the realization matrix
			for(var r = 0; r < referenceMoment.length; ++r) {
				matrix[r] = [];

				for(var c = 0; c < currentMoment.length; ++c)
					matrix[r][c] = referenceMoment[r] == currentMoment[c] ? 1 : 0;
			}

			return matrix;
		}

		// Compute the number of crossings in the given realization matrix
		var computeCrossings = function(matrix, referenceMoment, currentMoment) {
			var crossings = 0;

			for(var topRow = 0; topRow < referenceMoment.length - 1; ++topRow)
				for(var bottomRow = topRow + 1; bottomRow < referenceMoment.length; ++bottomRow)
					for(var leftColumn = 0; leftColumn < currentMoment.length - 1; ++leftColumn)
						for(var rightColumn = leftColumn + 1; rightColumn < currentMoment.length; ++rightColumn)
							crossings +=
									matrix[topRow][rightColumn] *
									matrix[bottomRow][leftColumn];

			return crossings;
		};

		var sortMoment = function(referenceMoment, currentMoment, sortRestrictions) {
			var columnBarycenters = [];
			var currentMapping = currentMoment.map(function(_, i, _) { return i; });
			var backupMapping = currentMoment.map(function(_, i, _) { return i; });
			var matrix = computeRealizationMatrix(referenceMoment, currentMoment);

			// Compute the column barycenters
			for(c = 0; c < currentMoment.length; ++c) {
				var weightedSum = 0;

				for (r = 0; r < referenceMoment.length; ++r) {
					weightedSum += (r + 1) * matrix[r][c];
				}

				columnBarycenters[c] = weightedSum;
			}

			// Compute the number of crossings before sorting the columns
			var crossingsBefore = computeCrossings(matrix, referenceMoment, currentMoment);

			// Sort the columns by their barycenters, while making sure that we respect the hierarchical structure
			for(var restriction = 0, offset = 0; restriction < sortRestrictions.length; ++restriction) {
				for(i = offset; i < offset + sortRestrictions[restriction]; ++i) {
					for(var k = i + 1; k < offset + sortRestrictions[restriction]; ++k)
						if(columnBarycenters[i] > columnBarycenters[k]) {
							var tmp = columnBarycenters[i];
							columnBarycenters[i] = columnBarycenters[k];
							columnBarycenters[k] = tmp;

							tmp = currentMapping[currentMapping[i]];
							currentMapping[currentMapping[i]] = currentMapping[currentMapping[k]];
							currentMapping[currentMapping[k]] = tmp;

							for(var r = 0; r < referenceMoment.length; ++r) {
								var tmp = matrix[r][currentMapping[i]];
								matrix[r][currentMapping.indexOf(i)] = matrix[r][currentMapping[k]];
								matrix[r][currentMapping.indexOf(k)] = tmp;
							}
						}
				}

				offset += sortRestrictions[restriction];
			}

			// Compute the number of crossings after column sorting
			var crossingsAfter = computeCrossings(matrix, referenceMoment, currentMoment);

			if(crossingsBefore <= crossingsAfter) {
				return { mapping: backupMapping, crossings: crossingsBefore };
			}

			return { mapping: currentMapping, crossings: crossingsAfter };
		};

		console.log("Starting sweeping...");

		var bestCrossings = -1;
		var bestDataset = jQuery.extend(true, {}, dataset);

		for(var iter = 0; iter < options.algorithm.sweepingMaxIterations; ++iter) {
			console.log("  Sweep #", iter);
			var totalCrossings = 0;

			// Sweep left->right
			for (t = timeframe.start + 1; t < timeframe.end; ++t) {
				var referenceMoment = dataset.d3.time[t - 1];
				var currentMoment = dataset.d3.time[t];

				var sortRestrictions = currentMoment.locations.
						map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
						reduce(function(x, y) { return x.concat(y); });

				var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);
				totalCrossings += result.crossings;

				enforceHierarchy(currentMoment, result.mapping, true);
			}

			if(bestCrossings == -1 || bestCrossings >= totalCrossings) {
				bestCrossings = totalCrossings;
				bestDataset = jQuery.extend(true, {}, dataset);
				console.log("Best number of crossings: ", bestCrossings);
			}

			totalCrossings = 0;

			// Set the order for all time frames as the order at the last time frame
			referenceMoment = dataset.d3.time[timeframe.end -2];
			currentMoment = dataset.d3.time[timeframe.end -1];

			// Sweep right->left to fix the order
			var sortRestrictions = currentMoment.locations.
					map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
					reduce(function(x, y) { return x.concat(y); });


			var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);

			for (t = timeframe.start + 1; t < timeframe.end; ++t) {
				dataset.d3.time[t].sortedCharacters.sort(function(x, y) {
					var xIndex = currentMoment.sortedCharacters.indexOf(x);
					var yIndex = currentMoment.sortedCharacters.indexOf(x);

					if(xIndex == -1) return false;
					if(yIndex == -1) return false;

					return result.mapping[xIndex] > result.mapping[yIndex];
				});

				var oneToOneMapping = dataset.d3.time[t].sortedCharacters.map(function(_, i, _) { return i; });

				enforceHierarchy(dataset.d3.time[t], oneToOneMapping, false);

				var ref = dataset.d3.time[t - 1].sortedCharacters;
				var cur = dataset.d3.time[t].sortedCharacters;

				totalCrossings += computeCrossings(computeRealizationMatrix(ref, cur), ref, cur);
			}

			// console.log("!!!", totalCrossings);

			if(bestCrossings == -1 || bestCrossings >= totalCrossings) {
				bestCrossings = totalCrossings;
				bestDataset = jQuery.extend(true, {}, dataset);
				console.log("Best number of crossings: ", bestCrossings);
			}

			totalCrossings = 0;

			// Sweep right->left
			for (t = timeframe.end - 2; t >= 0; --t) {
				referenceMoment = dataset.d3.time[t  + 1];
				currentMoment = dataset.d3.time[t];

				var sortRestrictions = currentMoment.locations.
						map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
						reduce(function(x, y) { return x.concat(y); });

				var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);
				totalCrossings += result.crossings;

				enforceHierarchy(currentMoment, result.mapping, true);
			}

			if(bestCrossings == -1 || bestCrossings >= totalCrossings) {
				bestCrossings = totalCrossings;
				bestDataset = jQuery.extend(true, {}, dataset);
				console.log("Best number of crossings: ", bestCrossings);
			}

			totalCrossings = 0;

			// Set the order for all time frames as the order at the first time frame
			referenceMoment = dataset.d3.time[timeframe.start];
			currentMoment = dataset.d3.time[timeframe.start + 1];

			// Sweep right->left to fix the order
			var sortRestrictions = currentMoment.locations.
					map(function(x) { return x.sessions.map(function(x) { return dataset.sessions[x].members.length; }) }).
					reduce(function(x, y) { return x.concat(y); });


			var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);

			for (t = timeframe.start + 1; t < timeframe.end; ++t) {
				dataset.d3.time[t].sortedCharacters.sort(function(x, y) {
					var xIndex = currentMoment.sortedCharacters.indexOf(x);
					var yIndex = currentMoment.sortedCharacters.indexOf(x);

					if(xIndex == -1) return false;
					if(yIndex == -1) return false;

					return result.mapping[xIndex] > result.mapping[yIndex];
				});

				var oneToOneMapping = dataset.d3.time[t].sortedCharacters.map(function(_, i, _) { return i; });

				enforceHierarchy(dataset.d3.time[t], oneToOneMapping, false);

				var ref = dataset.d3.time[t - 1].sortedCharacters;
				var cur = dataset.d3.time[t].sortedCharacters;

				totalCrossings += computeCrossings(computeRealizationMatrix(ref, cur), ref, cur);
			}

			if(bestCrossings == -1 || bestCrossings >= totalCrossings) {
				bestCrossings = totalCrossings;
				bestDataset = jQuery.extend(true, {}, dataset);
				console.log("Best number of crossings: ", bestCrossings);
			}
		}

		return bestDataset;
	}
</script>

<table>
	<tr>
		<td>
			<select name="dataset" id="dataset">
				<option value="dataset/the_matrix.json">The Matrix</option>
				<option value="dataset/alice_in_wonderland.json">Alice in Wonderland</option>
				<option value="dataset/star_wars.json" selected>Star Wars</option>
			</select>
		</td>
		<td>
			<select name="interpolation" id="interpolation">
				<option value="linear">Linear</option>
				<option value="step">Step</option>
				<option value="step-before">Step-before</option>
				<option value="step-after">Step-after</option>
				<option value="basis">Basis</option>
				<option value="bundle">Bundle</option>
				<option value="cardinal">Cardinal</option>
				<option value="monotone" selected>Monotone</option>
			</select>
		</td>
	</tr>
</table>

<div id="canvas"/>
</body>
</html>